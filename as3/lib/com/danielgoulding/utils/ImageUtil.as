package com.danielgoulding.utils {	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.GradientType;	import flash.display.IBitmapDrawable;	import flash.display.Shape;	import flash.display.SpreadMethod;	import flash.display.Sprite;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	/**	 * @author Dan	 */	public class ImageUtil {				/**		 * Reflection		 * 		 * @param source		: the bitmap to be reflected		 * @param mirrorX		: reflect by x axis		 * @param mirrorY		: reflect by y axis		 * @return				: reflection of a Bitmap with Alpha gradient		 * 		 * @author	Daniel Goulding <daniel.goulding@yeahlove.co.uk>		 */		public static function GradientReflection( source:Bitmap, mirrorX:Boolean=false, mirrorY:Boolean=true, gradientOptions:Object=null ) : Bitmap {			var mirrored:Bitmap = MirroredBitmap( source, mirrorX, mirrorY );			var gradientDirection:Number = 0;			if ( mirrorX && mirrorY ){				gradientDirection = ( 1 * Math.PI ) / 4;			}else if( mirrorX ){				gradientDirection = 0;			}else{				gradientDirection = ( 3 * Math.PI ) / 2;			}			return GradientBitmap( mirrored, gradientDirection, gradientOptions );		}				/**		 * Reflection		 * 		 * @param source		: the bitmap to be reflected		 * @param mirrorX		: reflect by x axis		 * @param mirrorY		: reflect by y axis		 * @return				: reflection of a Bitmap with Alpha gradient		 * 		 * @author	Daniel Goulding <daniel.goulding@yeahlove.co.uk>		 */		public static function AlphaReflection( source:Bitmap, mirrorX:Boolean=false, mirrorY:Boolean=true ) : Bitmap {			var mirrored:Bitmap = MirroredBitmap( source, mirrorX, mirrorY );			var gradientDirection:Number = 0;			if ( mirrorX && mirrorY ){				gradientDirection = ( 5 * Math.PI ) / 4;			}else if( mirrorX ){				gradientDirection = Math.PI;			}else{				gradientDirection = Math.PI/2;			}			return AlphaGradientBitmap( mirrored, gradientDirection );		}				/**		 * MirroredBitmap 		 * 		 * @param source		: the bitmap to be reflected		 * @param mirrorX		: reflect by x axis		 * @param mirrorY		: reflect by y axis		 * @return				: mirror image of bitmap, mirroed by x or y axis		 * 		 * @author	Daniel Goulding <daniel.goulding@yeahlove.co.uk>		 */		public static function MirroredBitmap( source:Bitmap, mirrorX:Boolean=false, mirrorY:Boolean=true ) : Bitmap {			var mirrored:BitmapData = new BitmapData( source.bitmapData.width, source.bitmapData.height, true, 0x00000000 );			var a:Number = mirrorX ? -1 : 1;			var d:Number = mirrorY ? -1 : 1;			var tx:Number = mirrorX ? mirrored.width : 0;			var ty:Number = mirrorY ? mirrored.height : 0;						var reflectionMatrix:Matrix = new Matrix( a, 0, 0, d, tx, ty );			mirrored.draw( source.bitmapData, reflectionMatrix );         			return new Bitmap( mirrored );		}				/**		 * AlphaGradientBitmap		 * 		 * @param source			: The source bitmap 		 * @param gradientDirection	: the gradient direction, in radians		 * @param gradientOptions	: the gradient options { type, colors, alphas, ratios }		 * @return					: Returns bitmap with alpha gradient		 * 		 * @author	Daniel Goulding <daniel.goulding@yeahlove.co.uk>		 */		public static function AlphaGradientBitmap( source:Bitmap, gradientDirection:Number=1.5708, gradientOptions:Object=null ) : Bitmap {						var gradient:Shape = GradientShape( source, gradientDirection, gradientOptions );						var gradientBitmap:BitmapData = new BitmapData( gradient.width, gradient.height, true, 0 );			gradientBitmap.draw( gradient );						var result:BitmapData = new BitmapData( source.width, source.height, true, 0 );			result.copyPixels( source.bitmapData, result.rect, new Point(), gradientBitmap, new Point(), true );						return new Bitmap( result );		}				/**		 * GradientBitmap		 * 		 * @param source			: The source bitmap 		 * @param gradientDirection	: the gradient direction, in radians		 * @param gradientOptions	: the gradient options { type, colors, alphas, ratios }		 * @return					: Returns bitmap with gradient		 * 		 * @author	Daniel Goulding <daniel.goulding@yeahlove.co.uk>		 */		public static function GradientBitmap( source:Bitmap, gradientDirection:Number=1.5708, gradientOptions:Object=null ) : Bitmap {						var gradient:Shape = GradientShape( source, gradientDirection, gradientOptions );						var bitmapData:BitmapData = new BitmapData( source.bitmapData.width, source.bitmapData.height, true, 0x00000000 );			bitmapData.draw( source.bitmapData );			bitmapData.draw( gradient );						return new Bitmap( bitmapData );		}				/**		 * Gradient		 * 		 * @param source			: The source bitmap 		 * @param gradientDirection	: the gradient direction, in radians		 * @param gradientOptions	: the gradient options { type, colors, alphas, ratios }		 * @return					: Returns gradient shape		 * 		 * @author	Daniel Goulding <daniel.goulding@yeahlove.co.uk>		 */		public static function GradientShape( source:Bitmap, gradientDirection:Number=1.5708, gradientOptions:Object=null ) : Shape {						var matrix:Matrix = new Matrix();			matrix.createGradientBox( source.width, source.height, gradientDirection );						var type:String = gradientOptions && gradientOptions[ "type" ] ? gradientOptions[ "type" ] : GradientType.LINEAR;			var colors:Array = gradientOptions && gradientOptions[ "colors" ] ? gradientOptions[ "colors" ] : [ 0xFFFFFF, 0xFFFFFF ];			var alphas:Array = gradientOptions && gradientOptions[ "alphas" ] ? gradientOptions[ "alphas" ] : [ 1, 0 ];			var ratios:Array = gradientOptions && gradientOptions[ "ratios" ] ? gradientOptions[ "ratios" ] : [ 0, 255 ];						var gradient:Shape = new Shape();			gradient.graphics.beginGradientFill( type, colors, alphas, ratios, matrix );			gradient.graphics.drawRect( 0, 0, source.width, source.height );			gradient.graphics.endFill();						return gradient;		}				/**		*	Generate a tiled displayobject with a bitmap:		* 		*	@param	tileLayer	the Sprite to add the tile to		*	@param 	area		the area needed to be tiled		*	@param	tile		the example tile bitmap data		*		*	@returns 	the tileLayer with bitmap tiling		*			*	@author	Daniel Goulding <daniel.goulding@yeahlove.co.uk>		*			* 	@langversion ActionScript 3.0		*	@playerversion Flash 9.0		*/		public static function TileBitmap(tileLayer:Sprite, area:Rectangle, tile:BitmapData):Sprite{						with(tileLayer.graphics){				clear();				beginBitmapFill(tile);				moveTo(0, 0);				lineTo(area.width, 0);				lineTo(area.width, area.height);				lineTo(0, area.height);				lineTo(0, 0);				endFill();			}						return tileLayer;		}						/**		 * Returns a BitmapData Instance of the image of the source DisplayObject / BitmapData		 * 		 * @param	source		the source bitmap data		 * @param	width		width of the resampled output image		 * @param	height		height of the resampled output image		 * 		 * @returns 	resampled output image at specified width & height		 * 		 * @author	<http://www.untoldentertainment.com/blog/2009/04/30/tutorial-resample-bitmaps-in-flash-as3/>		 * 		 */		public static function getResampledBitmapData( source : IBitmapDrawable , width : Number , height : Number ) : BitmapData {	 			var sourceBitmapData : BitmapData;	 			if ( source is DisplayObject ) { // if source is a DisplayObject instance				sourceBitmapData  = getBitmapDataFromDisplayObject( DisplayObject( source )  );			}else if ( source is BitmapData) { // if source is a BitmapData instance				sourceBitmapData = source as BitmapData;			}else { // break on unhandled source				return null; 			}						//set the scale for the draw operation, for the new width / height			var matrix : Matrix =  new Matrix();						matrix.scale( width / sourceBitmapData.width  , height / sourceBitmapData.height );	 			//create the resized bitmap data			var ouputBitmapData : BitmapData = new BitmapData( width, height , true , 0x00000000 );	 					//draw the source to the bitmapData instance			ouputBitmapData.draw( sourceBitmapData , matrix , null , null , null , true );	 					//dispose of temporary bitmap data			if ( source is DisplayObject ) sourceBitmapData.dispose();	 			return ouputBitmapData;	 		} 				/**		 * Returns a Bitmap of the image of the source DisplayObject / BitmapData		 * 		 * @param	source		the source bitmap data		 * @param	width		width of the resampled output image		 * @param	height		height of the resampled output image		 * 		 * @returns 	Bitmap (new width & height)		 * 		 * @author	<http://www.untoldentertainment.com/blog/2009/04/30/tutorial-resample-bitmaps-in-flash-as3/>		 */		public static function getResampledBitmap( source : IBitmapDrawable , width : Number , height : Number ) : Bitmap {			var bmp : Bitmap = new Bitmap( getResampledBitmapData( source , width, height ) );			bmp.smoothing = true;			return bmp;		}				/**		 * Creates a BitmapData instance which contains the image of the source DisplayObject		 * note : transformations will be reset		 * 		 * @param	source		display object		 * 		 * @returns 	BitmapData instance of source display object		 * 		 * @author	<http://www.untoldentertainment.com/blog/2009/04/30/tutorial-resample-bitmaps-in-flash-as3/>		 */		protected static function getBitmapDataFromDisplayObject( source : DisplayObject ) : BitmapData { 			//get the rectangle of the image data in the DisplayObject			var sourceRect : Rectangle = DisplayObject( source ).getBounds( DisplayObject( source ) ); 						//create a BitmapData instance to draw the DisplayObject to			var bitmapData : BitmapData = new BitmapData( sourceRect.width , sourceRect.height , true , 0x000000000 ); 			//draw the portion of the clip that contains image data			var matrix : Matrix = new Matrix();			matrix.translate( -sourceRect.x , -sourceRect.y );			bitmapData.draw( source , matrix , null , null , null , true ); 			return bitmapData;		}			}}