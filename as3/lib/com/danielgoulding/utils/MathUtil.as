package com.danielgoulding.utils {	/**	 * @author Dan	 */	public class MathUtil {				/**		 * Convert angle from degrees to radians		 * @param angleDegrees	: the angle in degrees		 * @return the angle in radians		 */		public static function angleRadians(angleDegrees:Number):Number{			return angleDegrees * (Math.PI / 180);		}				/**		 * Convert angle from degrees to radians		 * @param angleRadians	: the angle in radians		 * @return the angle in degrees		 */		public static function angleDegrees(angleRadians:Number):Number{			return angleRadians * (180 / Math.PI);		}				/**		 * Round to n decimal places:		 * @param p				: the number to round		 * @param numPlaces		: number of places to round to		 */		public static function Round( p:Number, numPlaces:int ):Number{			var m:Number = Math.pow(10, numPlaces);			return Math.round( p * m ) / m;		}				/**		 * Clamp number between two values:		 * @param value			: the number to be clamped		 * @param min			: the minimum value		 * @param max			: the max value		 * @return				: the clamped value		 * @example		 * 		MathUtil.Clamp( 20, 100, 300 ); (returns 100)		 */		public static function Clamp( value:Number, min:Number, max:Number ):Number{			if ( value < min ){				value = min;			}			if ( value > max ){				value = max;			}			return value;
		}
		/**		 * return nearest value to marker:		 * @param values		: array of values to test		 * @param marker		: the marker value		 * @example		 * 		MathUtil.Nearest( [10,100], 40 ); ( returns 10 )		 */
		public static function Nearest( values:Array, marker:Number ) : Number {			var i:int;			var n:int = values.length;			var testValue:Number = Math.abs( values[i] - marker );			var returnValue:Number = values[i];			for ( i=0; i<n; i++ ) {				if ( testValue > Math.abs( values[i] - marker ) ){					testValue = Math.abs( values[i] - marker );					returnValue = values[i];				}			}			return returnValue;
		}
			}}